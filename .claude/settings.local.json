{
  "permissions": {
    "allow": [
      "Bash(wc:*)",
      "Bash(./setup-check.sh:*)",
      "Bash(npm install:*)",
      "Bash(npm run dev:*)",
      "Bash(curl:*)",
      "Bash(npx vercel login:*)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n *\n * GET /api/health\n *\n * Returns system health status and version information\n */\n\nimport { supabaseAdmin } from '../lib/supabase.js';\n\nexport const config = {\n  runtime: 'edge',\n};\n\nexport default async function handler\\(req: Request\\) {\n  if \\(req.method !== 'GET'\\) {\n    return new Response\\(JSON.stringify\\({\n      error: 'Method not allowed',\n      message: 'Only GET requests are allowed'\n    }\\), {\n      status: 405,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  }\n\n  try {\n    // Test Supabase connection\n    const { error: dbError } = await supabaseAdmin\n      .from\\('profiles'\\)\n      .select\\('count'\\)\n      .limit\\(1\\);\n\n    const supabaseStatus = dbError ? 'unhealthy' : 'healthy';\n\n    return new Response\\(JSON.stringify\\({\n      status: 'healthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      version: '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      services: {\n        supabase: supabaseStatus,\n        api: 'healthy'\n      }\n    }\\), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  } catch \\(error\\) {\n    console.error\\('Health check failed:', error\\);\n\n    return new Response\\(JSON.stringify\\({\n      status: 'unhealthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      error: 'Service unavailable',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }\\), {\n      status: 503,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  }\n}\nEOF)",
      "Bash(pbcopy:*)",
      "Bash(grep:*)",
      "Bash(schema-full.sql << 'EOFSCHEMA'\n-- ========================================\n-- DualTetraX Services - Complete Database Schema\n-- Version: 1.0 | Date: 2026-02-08\n-- ========================================\n\n-- Utility Function \\(Required First\\)\nCREATE OR REPLACE FUNCTION update_updated_at_column\\(\\)\nRETURNS TRIGGER AS $\nBEGIN\n  NEW.updated_at = NOW\\(\\);\n  RETURN NEW;\nEND;\n$ LANGUAGE plpgsql;\n\n-- ========================================\n-- PROFILES TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.profiles \\(\n  id UUID REFERENCES auth.users\\(id\\) ON DELETE CASCADE PRIMARY KEY,\n  email TEXT UNIQUE NOT NULL,\n  name TEXT,\n  profile_image_url TEXT,\n  phone_number TEXT,\n  date_of_birth DATE,\n  gender TEXT CHECK \\(gender IN \\('male', 'female', 'other', 'prefer_not_to_say'\\)\\),\n  push_notifications_enabled BOOLEAN DEFAULT TRUE,\n  email_notifications_enabled BOOLEAN DEFAULT TRUE,\n  marketing_notifications_enabled BOOLEAN DEFAULT FALSE,\n  usage_reminder_enabled BOOLEAN DEFAULT TRUE,\n  usage_reminder_time TIME DEFAULT '20:00:00',\n  is_active BOOLEAN DEFAULT TRUE,\n  is_beta_tester BOOLEAN DEFAULT FALSE,\n  role TEXT DEFAULT 'user' CHECK \\(role IN \\('user', 'admin', 'analyst'\\)\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  last_login_at TIMESTAMP WITH TIME ZONE\n\\);\n\nALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view their own profile\" ON public.profiles FOR SELECT USING \\(auth.uid\\(\\) = id\\);\nCREATE POLICY \"Users can update their own profile\" ON public.profiles FOR UPDATE USING \\(auth.uid\\(\\) = id\\) WITH CHECK \\(role = \\(SELECT role FROM public.profiles WHERE id = auth.uid\\(\\)\\)\\);\nCREATE POLICY \"Admins can view all profiles\" ON public.profiles FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_profiles_email ON public.profiles\\(email\\);\nCREATE INDEX idx_profiles_role ON public.profiles\\(role\\);\nCREATE INDEX idx_profiles_created_at ON public.profiles\\(created_at DESC\\);\n\nCREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\nCREATE OR REPLACE FUNCTION create_profile_for_new_user\\(\\) RETURNS TRIGGER AS $\nBEGIN\n  INSERT INTO public.profiles \\(id, email\\) VALUES \\(NEW.id, NEW.email\\);\n  RETURN NEW;\nEND;\n$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION create_profile_for_new_user\\(\\);\nEOFSCHEMA)",
      "Bash(schema-full.sql << 'EOFDEVICES'\n\n-- ========================================\n-- DEVICES TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.devices \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  serial_number TEXT UNIQUE NOT NULL,\n  model_name TEXT NOT NULL,\n  firmware_version TEXT NOT NULL,\n  firmware_updated_at TIMESTAMP WITH TIME ZONE,\n  is_active BOOLEAN DEFAULT TRUE,\n  last_connected_at TIMESTAMP WITH TIME ZONE,\n  connection_count INT DEFAULT 0,\n  ble_mac_address TEXT,\n  hardware_revision TEXT,\n  manufacturing_date DATE,\n  tags TEXT[] DEFAULT '{}',\n  registered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  CONSTRAINT valid_serial_number CHECK \\(char_length\\(serial_number\\) > 0\\)\n\\);\n\nALTER TABLE public.devices ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own devices\" ON public.devices FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can insert their own devices\" ON public.devices FOR INSERT WITH CHECK \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can update their own devices\" ON public.devices FOR UPDATE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can delete their own devices\" ON public.devices FOR DELETE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all devices\" ON public.devices FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_devices_user_id ON public.devices\\(user_id\\);\nCREATE INDEX idx_devices_serial_number ON public.devices\\(serial_number\\);\nCREATE INDEX idx_devices_firmware_version ON public.devices\\(firmware_version\\);\nCREATE INDEX idx_devices_last_connected_at ON public.devices\\(last_connected_at DESC\\);\nCREATE TRIGGER update_devices_updated_at BEFORE UPDATE ON public.devices FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\n-- ========================================\n-- USAGE SESSIONS TABLE  \n-- ========================================\nCREATE TABLE IF NOT EXISTS public.usage_sessions \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  device_id UUID REFERENCES public.devices\\(id\\) ON DELETE CASCADE NOT NULL,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  shot_type TEXT NOT NULL CHECK \\(shot_type IN \\('USHOT', 'ESHOT', 'LED'\\)\\),\n  device_mode TEXT NOT NULL,\n  level INT NOT NULL CHECK \\(level BETWEEN 1 AND 3\\),\n  start_time TIMESTAMP WITH TIME ZONE NOT NULL,\n  end_time TIMESTAMP WITH TIME ZONE,\n  working_duration INT,\n  pause_duration INT,\n  battery_start INT CHECK \\(battery_start BETWEEN 0 AND 100\\),\n  battery_end INT CHECK \\(battery_end BETWEEN 0 AND 100\\),\n  warning_occurred BOOLEAN DEFAULT FALSE,\n  warning_types TEXT[],\n  local_session_id TEXT,\n  synced_from_device_at TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  UNIQUE \\(device_id, local_session_id\\)\n\\);\n\nALTER TABLE public.usage_sessions ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own sessions\" ON public.usage_sessions FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can insert their own sessions\" ON public.usage_sessions FOR INSERT WITH CHECK \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can delete their own sessions\" ON public.usage_sessions FOR DELETE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all sessions\" ON public.usage_sessions FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_sessions_user_id_start_time ON public.usage_sessions\\(user_id, start_time DESC\\);\nCREATE INDEX idx_sessions_device_id_start_time ON public.usage_sessions\\(device_id, start_time DESC\\);\nCREATE INDEX idx_sessions_start_time ON public.usage_sessions\\(start_time DESC\\);\n\n-- ========================================\n-- DAILY STATISTICS TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.daily_statistics \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  device_id UUID REFERENCES public.devices\\(id\\) ON DELETE CASCADE NOT NULL,\n  stat_date DATE NOT NULL,\n  total_sessions INT DEFAULT 0,\n  total_working_duration INT DEFAULT 0,\n  total_pause_duration INT DEFAULT 0,\n  ushot_sessions INT DEFAULT 0,\n  ushot_duration INT DEFAULT 0,\n  eshot_sessions INT DEFAULT 0,\n  eshot_duration INT DEFAULT 0,\n  led_sessions INT DEFAULT 0,\n  led_duration INT DEFAULT 0,\n  mode_breakdown JSONB DEFAULT '{}',\n  level_breakdown JSONB DEFAULT '{}',\n  warning_count INT DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  UNIQUE \\(device_id, stat_date\\)\n\\);\n\nALTER TABLE public.daily_statistics ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own statistics\" ON public.daily_statistics FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all statistics\" ON public.daily_statistics FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\nCREATE INDEX idx_daily_stats_user_date ON public.daily_statistics\\(user_id, stat_date DESC\\);\nCREATE INDEX idx_daily_stats_device_date ON public.daily_statistics\\(device_id, stat_date DESC\\);\nCREATE TRIGGER update_daily_statistics_updated_at BEFORE UPDATE ON public.daily_statistics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\n-- Aggregation Function\nCREATE OR REPLACE FUNCTION aggregate_daily_stats\\(target_date DATE\\) RETURNS VOID AS $\nBEGIN\n  INSERT INTO public.daily_statistics \\(user_id, device_id, stat_date, total_sessions, total_working_duration, total_pause_duration, ushot_sessions, ushot_duration, eshot_sessions, eshot_duration, led_sessions, led_duration, warning_count\\)\n  SELECT user_id, device_id, target_date, COUNT\\(*\\), SUM\\(COALESCE\\(working_duration, 0\\)\\), SUM\\(COALESCE\\(pause_duration, 0\\)\\),\n    SUM\\(CASE WHEN shot_type = 'USHOT' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'USHOT' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN shot_type = 'ESHOT' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'ESHOT' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN shot_type = 'LED' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'LED' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN warning_occurred THEN 1 ELSE 0 END\\)\n  FROM public.usage_sessions WHERE DATE\\(start_time\\) = target_date GROUP BY user_id, device_id\n  ON CONFLICT \\(device_id, stat_date\\) DO UPDATE SET total_sessions = EXCLUDED.total_sessions, updated_at = NOW\\(\\);\nEND;\n$ LANGUAGE plpgsql;\n\n-- ========================================\n-- FIRMWARE TABLES\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.firmware_versions \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  version TEXT UNIQUE NOT NULL,\n  version_code INT UNIQUE NOT NULL,\n  storage_path TEXT NOT NULL,\n  file_size_bytes BIGINT NOT NULL,\n  checksum_sha256 TEXT NOT NULL,\n  compatible_models TEXT[] DEFAULT '{\"DualTetraX Pro\"}',\n  changelog TEXT,\n  is_stable BOOLEAN DEFAULT FALSE,\n  is_active BOOLEAN DEFAULT TRUE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nCREATE TABLE IF NOT EXISTS public.skin_profiles \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE UNIQUE NOT NULL,\n  skin_type TEXT CHECK \\(skin_type IN \\('dry', 'oily', 'combination', 'sensitive', 'normal'\\)\\),\n  concerns TEXT[] DEFAULT '{}',\n  weekly_goal_sessions INT DEFAULT 3,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nALTER TABLE public.skin_profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can manage their own skin profile\" ON public.skin_profiles FOR ALL USING \\(auth.uid\\(\\) = user_id\\);\n\nCREATE TABLE IF NOT EXISTS public.notifications \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  notification_type TEXT NOT NULL CHECK \\(notification_type IN \\('push', 'email', 'in_app'\\)\\),\n  category TEXT NOT NULL,\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  status TEXT DEFAULT 'pending' CHECK \\(status IN \\('pending', 'sent', 'failed', 'read'\\)\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own notifications\" ON public.notifications FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE INDEX idx_notifications_user_id ON public.notifications\\(user_id, created_at DESC\\);\n\n-- Success Message\nDO $ BEGIN\n  RAISE NOTICE 'âœ… DualTetraX Complete Database Schema Applied Successfully!';\n  RAISE NOTICE '   ðŸ“Š 13 tables created';\n  RAISE NOTICE '   ðŸ”’ Row Level Security enabled';\n  RAISE NOTICE '   ðŸ“ˆ All indexes created';\nEND $;\nEOFDEVICES)",
      "Bash(schema-complete-13tables.sql:*)",
      "Bash(vercel:*)",
      "Bash(npm run type-check:*)",
      "Bash(find:*)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n *\n * GET /api/health\n *\n * Returns system health status and version information\n */\n\nimport { supabaseAdmin } from '../lib/supabase';\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\n\nexport default async function handler\\(req: VercelRequest, res: VercelResponse\\) {\n  if \\(req.method !== 'GET'\\) {\n    return res.status\\(405\\).json\\({\n      error: 'Method not allowed',\n      message: 'Only GET requests are allowed'\n    }\\);\n  }\n\n  try {\n    // Test Supabase connection\n    const { error: dbError } = await supabaseAdmin\n      .from\\('profiles'\\)\n      .select\\('count'\\)\n      .limit\\(1\\);\n\n    const supabaseStatus = dbError ? 'unhealthy' : 'healthy';\n\n    return res.status\\(200\\).json\\({\n      status: 'healthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      version: '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      services: {\n        supabase: supabaseStatus,\n        api: 'healthy'\n      }\n    }\\);\n  } catch \\(error\\) {\n    console.error\\('Health check failed:', error\\);\n\n    return res.status\\(503\\).json\\({\n      status: 'unhealthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      error: 'Service unavailable',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }\\);\n  }\n}\nEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n */\n\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\n\nexport default async function handler\\(req: VercelRequest, res: VercelResponse\\) {\n  if \\(req.method !== 'GET'\\) {\n    return res.status\\(405\\).json\\({\n      error: 'Method not allowed'\n    }\\);\n  }\n\n  const hasSupabaseUrl = !!process.env.SUPABASE_URL;\n  const hasSupabaseKey = !!process.env.SUPABASE_SERVICE_ROLE_KEY;\n  const hasRedisUrl = !!process.env.UPSTASH_REDIS_REST_URL;\n  const hasRedisToken = !!process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  return res.status\\(200\\).json\\({\n    status: 'healthy',\n    timestamp: new Date\\(\\).toISOString\\(\\),\n    version: '1.0.0',\n    environment: process.env.NODE_ENV || 'development',\n    config: {\n      supabase_url_set: hasSupabaseUrl,\n      supabase_key_set: hasSupabaseKey,\n      redis_url_set: hasRedisUrl,\n      redis_token_set: hasRedisToken\n    }\n  }\\);\n}\nEOF)",
      "Bash(npm run build:*)"
    ]
  }
}
