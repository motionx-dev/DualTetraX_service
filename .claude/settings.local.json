{
  "permissions": {
    "allow": [
      "Bash(wc:*)",
      "Bash(./setup-check.sh:*)",
      "Bash(npm install:*)",
      "Bash(npm run dev:*)",
      "Bash(curl:*)",
      "Bash(npx vercel login:*)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n *\n * GET /api/health\n *\n * Returns system health status and version information\n */\n\nimport { supabaseAdmin } from '../lib/supabase.js';\n\nexport const config = {\n  runtime: 'edge',\n};\n\nexport default async function handler\\(req: Request\\) {\n  if \\(req.method !== 'GET'\\) {\n    return new Response\\(JSON.stringify\\({\n      error: 'Method not allowed',\n      message: 'Only GET requests are allowed'\n    }\\), {\n      status: 405,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  }\n\n  try {\n    // Test Supabase connection\n    const { error: dbError } = await supabaseAdmin\n      .from\\('profiles'\\)\n      .select\\('count'\\)\n      .limit\\(1\\);\n\n    const supabaseStatus = dbError ? 'unhealthy' : 'healthy';\n\n    return new Response\\(JSON.stringify\\({\n      status: 'healthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      version: '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      services: {\n        supabase: supabaseStatus,\n        api: 'healthy'\n      }\n    }\\), {\n      status: 200,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  } catch \\(error\\) {\n    console.error\\('Health check failed:', error\\);\n\n    return new Response\\(JSON.stringify\\({\n      status: 'unhealthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      error: 'Service unavailable',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }\\), {\n      status: 503,\n      headers: { 'Content-Type': 'application/json' },\n    }\\);\n  }\n}\nEOF)",
      "Bash(pbcopy:*)",
      "Bash(grep:*)",
      "Bash(schema-full.sql << 'EOFSCHEMA'\n-- ========================================\n-- DualTetraX Services - Complete Database Schema\n-- Version: 1.0 | Date: 2026-02-08\n-- ========================================\n\n-- Utility Function \\(Required First\\)\nCREATE OR REPLACE FUNCTION update_updated_at_column\\(\\)\nRETURNS TRIGGER AS $\nBEGIN\n  NEW.updated_at = NOW\\(\\);\n  RETURN NEW;\nEND;\n$ LANGUAGE plpgsql;\n\n-- ========================================\n-- PROFILES TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.profiles \\(\n  id UUID REFERENCES auth.users\\(id\\) ON DELETE CASCADE PRIMARY KEY,\n  email TEXT UNIQUE NOT NULL,\n  name TEXT,\n  profile_image_url TEXT,\n  phone_number TEXT,\n  date_of_birth DATE,\n  gender TEXT CHECK \\(gender IN \\('male', 'female', 'other', 'prefer_not_to_say'\\)\\),\n  push_notifications_enabled BOOLEAN DEFAULT TRUE,\n  email_notifications_enabled BOOLEAN DEFAULT TRUE,\n  marketing_notifications_enabled BOOLEAN DEFAULT FALSE,\n  usage_reminder_enabled BOOLEAN DEFAULT TRUE,\n  usage_reminder_time TIME DEFAULT '20:00:00',\n  is_active BOOLEAN DEFAULT TRUE,\n  is_beta_tester BOOLEAN DEFAULT FALSE,\n  role TEXT DEFAULT 'user' CHECK \\(role IN \\('user', 'admin', 'analyst'\\)\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  last_login_at TIMESTAMP WITH TIME ZONE\n\\);\n\nALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view their own profile\" ON public.profiles FOR SELECT USING \\(auth.uid\\(\\) = id\\);\nCREATE POLICY \"Users can update their own profile\" ON public.profiles FOR UPDATE USING \\(auth.uid\\(\\) = id\\) WITH CHECK \\(role = \\(SELECT role FROM public.profiles WHERE id = auth.uid\\(\\)\\)\\);\nCREATE POLICY \"Admins can view all profiles\" ON public.profiles FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_profiles_email ON public.profiles\\(email\\);\nCREATE INDEX idx_profiles_role ON public.profiles\\(role\\);\nCREATE INDEX idx_profiles_created_at ON public.profiles\\(created_at DESC\\);\n\nCREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\nCREATE OR REPLACE FUNCTION create_profile_for_new_user\\(\\) RETURNS TRIGGER AS $\nBEGIN\n  INSERT INTO public.profiles \\(id, email\\) VALUES \\(NEW.id, NEW.email\\);\n  RETURN NEW;\nEND;\n$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION create_profile_for_new_user\\(\\);\nEOFSCHEMA)",
      "Bash(schema-full.sql << 'EOFDEVICES'\n\n-- ========================================\n-- DEVICES TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.devices \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  serial_number TEXT UNIQUE NOT NULL,\n  model_name TEXT NOT NULL,\n  firmware_version TEXT NOT NULL,\n  firmware_updated_at TIMESTAMP WITH TIME ZONE,\n  is_active BOOLEAN DEFAULT TRUE,\n  last_connected_at TIMESTAMP WITH TIME ZONE,\n  connection_count INT DEFAULT 0,\n  ble_mac_address TEXT,\n  hardware_revision TEXT,\n  manufacturing_date DATE,\n  tags TEXT[] DEFAULT '{}',\n  registered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  CONSTRAINT valid_serial_number CHECK \\(char_length\\(serial_number\\) > 0\\)\n\\);\n\nALTER TABLE public.devices ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own devices\" ON public.devices FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can insert their own devices\" ON public.devices FOR INSERT WITH CHECK \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can update their own devices\" ON public.devices FOR UPDATE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can delete their own devices\" ON public.devices FOR DELETE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all devices\" ON public.devices FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_devices_user_id ON public.devices\\(user_id\\);\nCREATE INDEX idx_devices_serial_number ON public.devices\\(serial_number\\);\nCREATE INDEX idx_devices_firmware_version ON public.devices\\(firmware_version\\);\nCREATE INDEX idx_devices_last_connected_at ON public.devices\\(last_connected_at DESC\\);\nCREATE TRIGGER update_devices_updated_at BEFORE UPDATE ON public.devices FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\n-- ========================================\n-- USAGE SESSIONS TABLE  \n-- ========================================\nCREATE TABLE IF NOT EXISTS public.usage_sessions \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  device_id UUID REFERENCES public.devices\\(id\\) ON DELETE CASCADE NOT NULL,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  shot_type TEXT NOT NULL CHECK \\(shot_type IN \\('USHOT', 'ESHOT', 'LED'\\)\\),\n  device_mode TEXT NOT NULL,\n  level INT NOT NULL CHECK \\(level BETWEEN 1 AND 3\\),\n  start_time TIMESTAMP WITH TIME ZONE NOT NULL,\n  end_time TIMESTAMP WITH TIME ZONE,\n  working_duration INT,\n  pause_duration INT,\n  battery_start INT CHECK \\(battery_start BETWEEN 0 AND 100\\),\n  battery_end INT CHECK \\(battery_end BETWEEN 0 AND 100\\),\n  warning_occurred BOOLEAN DEFAULT FALSE,\n  warning_types TEXT[],\n  local_session_id TEXT,\n  synced_from_device_at TIMESTAMP WITH TIME ZONE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  UNIQUE \\(device_id, local_session_id\\)\n\\);\n\nALTER TABLE public.usage_sessions ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own sessions\" ON public.usage_sessions FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can insert their own sessions\" ON public.usage_sessions FOR INSERT WITH CHECK \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Users can delete their own sessions\" ON public.usage_sessions FOR DELETE USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all sessions\" ON public.usage_sessions FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\n\nCREATE INDEX idx_sessions_user_id_start_time ON public.usage_sessions\\(user_id, start_time DESC\\);\nCREATE INDEX idx_sessions_device_id_start_time ON public.usage_sessions\\(device_id, start_time DESC\\);\nCREATE INDEX idx_sessions_start_time ON public.usage_sessions\\(start_time DESC\\);\n\n-- ========================================\n-- DAILY STATISTICS TABLE\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.daily_statistics \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  device_id UUID REFERENCES public.devices\\(id\\) ON DELETE CASCADE NOT NULL,\n  stat_date DATE NOT NULL,\n  total_sessions INT DEFAULT 0,\n  total_working_duration INT DEFAULT 0,\n  total_pause_duration INT DEFAULT 0,\n  ushot_sessions INT DEFAULT 0,\n  ushot_duration INT DEFAULT 0,\n  eshot_sessions INT DEFAULT 0,\n  eshot_duration INT DEFAULT 0,\n  led_sessions INT DEFAULT 0,\n  led_duration INT DEFAULT 0,\n  mode_breakdown JSONB DEFAULT '{}',\n  level_breakdown JSONB DEFAULT '{}',\n  warning_count INT DEFAULT 0,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  UNIQUE \\(device_id, stat_date\\)\n\\);\n\nALTER TABLE public.daily_statistics ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own statistics\" ON public.daily_statistics FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE POLICY \"Admins can view all statistics\" ON public.daily_statistics FOR SELECT USING \\(auth.uid\\(\\) IN \\(SELECT id FROM profiles WHERE role = 'admin'\\)\\);\nCREATE INDEX idx_daily_stats_user_date ON public.daily_statistics\\(user_id, stat_date DESC\\);\nCREATE INDEX idx_daily_stats_device_date ON public.daily_statistics\\(device_id, stat_date DESC\\);\nCREATE TRIGGER update_daily_statistics_updated_at BEFORE UPDATE ON public.daily_statistics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column\\(\\);\n\n-- Aggregation Function\nCREATE OR REPLACE FUNCTION aggregate_daily_stats\\(target_date DATE\\) RETURNS VOID AS $\nBEGIN\n  INSERT INTO public.daily_statistics \\(user_id, device_id, stat_date, total_sessions, total_working_duration, total_pause_duration, ushot_sessions, ushot_duration, eshot_sessions, eshot_duration, led_sessions, led_duration, warning_count\\)\n  SELECT user_id, device_id, target_date, COUNT\\(*\\), SUM\\(COALESCE\\(working_duration, 0\\)\\), SUM\\(COALESCE\\(pause_duration, 0\\)\\),\n    SUM\\(CASE WHEN shot_type = 'USHOT' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'USHOT' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN shot_type = 'ESHOT' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'ESHOT' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN shot_type = 'LED' THEN 1 ELSE 0 END\\), SUM\\(CASE WHEN shot_type = 'LED' THEN COALESCE\\(working_duration, 0\\) ELSE 0 END\\),\n    SUM\\(CASE WHEN warning_occurred THEN 1 ELSE 0 END\\)\n  FROM public.usage_sessions WHERE DATE\\(start_time\\) = target_date GROUP BY user_id, device_id\n  ON CONFLICT \\(device_id, stat_date\\) DO UPDATE SET total_sessions = EXCLUDED.total_sessions, updated_at = NOW\\(\\);\nEND;\n$ LANGUAGE plpgsql;\n\n-- ========================================\n-- FIRMWARE TABLES\n-- ========================================\nCREATE TABLE IF NOT EXISTS public.firmware_versions \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  version TEXT UNIQUE NOT NULL,\n  version_code INT UNIQUE NOT NULL,\n  storage_path TEXT NOT NULL,\n  file_size_bytes BIGINT NOT NULL,\n  checksum_sha256 TEXT NOT NULL,\n  compatible_models TEXT[] DEFAULT '{\"DualTetraX Pro\"}',\n  changelog TEXT,\n  is_stable BOOLEAN DEFAULT FALSE,\n  is_active BOOLEAN DEFAULT TRUE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nCREATE TABLE IF NOT EXISTS public.skin_profiles \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE UNIQUE NOT NULL,\n  skin_type TEXT CHECK \\(skin_type IN \\('dry', 'oily', 'combination', 'sensitive', 'normal'\\)\\),\n  concerns TEXT[] DEFAULT '{}',\n  weekly_goal_sessions INT DEFAULT 3,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nALTER TABLE public.skin_profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can manage their own skin profile\" ON public.skin_profiles FOR ALL USING \\(auth.uid\\(\\) = user_id\\);\n\nCREATE TABLE IF NOT EXISTS public.notifications \\(\n  id UUID DEFAULT gen_random_uuid\\(\\) PRIMARY KEY,\n  user_id UUID REFERENCES public.profiles\\(id\\) ON DELETE CASCADE NOT NULL,\n  notification_type TEXT NOT NULL CHECK \\(notification_type IN \\('push', 'email', 'in_app'\\)\\),\n  category TEXT NOT NULL,\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  status TEXT DEFAULT 'pending' CHECK \\(status IN \\('pending', 'sent', 'failed', 'read'\\)\\),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW\\(\\)\n\\);\n\nALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can view their own notifications\" ON public.notifications FOR SELECT USING \\(auth.uid\\(\\) = user_id\\);\nCREATE INDEX idx_notifications_user_id ON public.notifications\\(user_id, created_at DESC\\);\n\n-- Success Message\nDO $ BEGIN\n  RAISE NOTICE 'âœ… DualTetraX Complete Database Schema Applied Successfully!';\n  RAISE NOTICE '   ðŸ“Š 13 tables created';\n  RAISE NOTICE '   ðŸ”’ Row Level Security enabled';\n  RAISE NOTICE '   ðŸ“ˆ All indexes created';\nEND $;\nEOFDEVICES)",
      "Bash(schema-complete-13tables.sql:*)",
      "Bash(vercel:*)",
      "Bash(npm run type-check:*)",
      "Bash(find:*)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n *\n * GET /api/health\n *\n * Returns system health status and version information\n */\n\nimport { supabaseAdmin } from '../lib/supabase';\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\n\nexport default async function handler\\(req: VercelRequest, res: VercelResponse\\) {\n  if \\(req.method !== 'GET'\\) {\n    return res.status\\(405\\).json\\({\n      error: 'Method not allowed',\n      message: 'Only GET requests are allowed'\n    }\\);\n  }\n\n  try {\n    // Test Supabase connection\n    const { error: dbError } = await supabaseAdmin\n      .from\\('profiles'\\)\n      .select\\('count'\\)\n      .limit\\(1\\);\n\n    const supabaseStatus = dbError ? 'unhealthy' : 'healthy';\n\n    return res.status\\(200\\).json\\({\n      status: 'healthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      version: '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      services: {\n        supabase: supabaseStatus,\n        api: 'healthy'\n      }\n    }\\);\n  } catch \\(error\\) {\n    console.error\\('Health check failed:', error\\);\n\n    return res.status\\(503\\).json\\({\n      status: 'unhealthy',\n      timestamp: new Date\\(\\).toISOString\\(\\),\n      error: 'Service unavailable',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }\\);\n  }\n}\nEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/backend/api/health.ts << 'EOF'\n/**\n * Health Check API\n */\n\nimport type { VercelRequest, VercelResponse } from '@vercel/node';\n\nexport default async function handler\\(req: VercelRequest, res: VercelResponse\\) {\n  if \\(req.method !== 'GET'\\) {\n    return res.status\\(405\\).json\\({\n      error: 'Method not allowed'\n    }\\);\n  }\n\n  const hasSupabaseUrl = !!process.env.SUPABASE_URL;\n  const hasSupabaseKey = !!process.env.SUPABASE_SERVICE_ROLE_KEY;\n  const hasRedisUrl = !!process.env.UPSTASH_REDIS_REST_URL;\n  const hasRedisToken = !!process.env.UPSTASH_REDIS_REST_TOKEN;\n\n  return res.status\\(200\\).json\\({\n    status: 'healthy',\n    timestamp: new Date\\(\\).toISOString\\(\\),\n    version: '1.0.0',\n    environment: process.env.NODE_ENV || 'development',\n    config: {\n      supabase_url_set: hasSupabaseUrl,\n      supabase_key_set: hasSupabaseKey,\n      redis_url_set: hasRedisUrl,\n      redis_token_set: hasRedisToken\n    }\n  }\\);\n}\nEOF)",
      "Bash(npm run build:*)",
      "Bash(npx create-next-app@14:*)",
      "Bash(python3:*)",
      "Bash(npx vercel:*)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/core/config/app_config.dart << 'DARTEOF'\nclass AppConfig {\n  static const String supabaseUrl = 'https://jivpguvyrrazbdczlfyg.supabase.co';\n  static const String supabaseAnonKey =\n      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImppdnBndXZ5cnJhemJkY3psZnlnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1Mzc3NjUsImV4cCI6MjA4NjExMzc2NX0.Dp5VDevOpMXB5xfzJUNdjizq60VHgjMdYuf3jvaPq60';\n  static const String apiBaseUrl = 'https://qp-dualtetrax-api.vercel.app';\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/auth_user.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass AuthUser extends Equatable {\n  final String id;\n  final String email;\n  final String? name;\n  final String? role;\n\n  const AuthUser\\({\n    required this.id,\n    required this.email,\n    this.name,\n    this.role,\n  }\\);\n\n  bool get isAdmin => role == 'admin';\n\n  @override\n  List<Object?> get props => [id, email, name, role];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/core/network/api_client.dart << 'DARTEOF'\nimport 'package:dio/dio.dart';\nimport 'package:supabase_flutter/supabase_flutter.dart';\nimport '../config/app_config.dart';\n\nclass ApiClient {\n  late final Dio _dio;\n\n  ApiClient\\(\\) {\n    _dio = Dio\\(BaseOptions\\(\n      baseUrl: AppConfig.apiBaseUrl,\n      connectTimeout: const Duration\\(seconds: 15\\),\n      receiveTimeout: const Duration\\(seconds: 15\\),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    \\)\\);\n\n    _dio.interceptors.add\\(AuthInterceptor\\(\\)\\);\n    _dio.interceptors.add\\(LogInterceptor\\(\n      requestBody: true,\n      responseBody: true,\n      logPrint: \\(o\\) => print\\('[API] $o'\\),\n    \\)\\);\n  }\n\n  Dio get dio => _dio;\n\n  Future<Response<T>> get<T>\\(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n  }\\) {\n    return _dio.get<T>\\(path, queryParameters: queryParameters\\);\n  }\n\n  Future<Response<T>> post<T>\\(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n  }\\) {\n    return _dio.post<T>\\(path, data: data, queryParameters: queryParameters\\);\n  }\n\n  Future<Response<T>> put<T>\\(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n  }\\) {\n    return _dio.put<T>\\(path, data: data, queryParameters: queryParameters\\);\n  }\n\n  Future<Response<T>> delete<T>\\(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n  }\\) {\n    return _dio.delete<T>\\(path, queryParameters: queryParameters\\);\n  }\n}\n\nclass AuthInterceptor extends Interceptor {\n  @override\n  void onRequest\\(RequestOptions options, RequestInterceptorHandler handler\\) {\n    final session = Supabase.instance.client.auth.currentSession;\n    if \\(session != null\\) {\n      options.headers['Authorization'] = 'Bearer ${session.accessToken}';\n    }\n    handler.next\\(options\\);\n  }\n\n  @override\n  Future<void> onError\\(DioException err, ErrorInterceptorHandler handler\\) async {\n    if \\(err.response?.statusCode == 401\\) {\n      try {\n        final response = await Supabase.instance.client.auth.refreshSession\\(\\);\n        if \\(response.session != null\\) {\n          err.requestOptions.headers['Authorization'] =\n              'Bearer ${response.session!.accessToken}';\n          final retryResponse = await Dio\\(\\).fetch\\(err.requestOptions\\);\n          return handler.resolve\\(retryResponse\\);\n        }\n      } catch \\(_\\) {}\n    }\n    handler.next\\(err\\);\n  }\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/user_profile.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass UserProfile extends Equatable {\n  final String id;\n  final String email;\n  final String? name;\n  final String? gender;\n  final DateTime? dateOfBirth;\n  final String? timezone;\n\n  const UserProfile\\({\n    required this.id,\n    required this.email,\n    this.name,\n    this.gender,\n    this.dateOfBirth,\n    this.timezone,\n  }\\);\n\n  @override\n  List<Object?> get props => [id, email, name, gender, dateOfBirth, timezone];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/core/network/network_info.dart << 'DARTEOF'\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nabstract class NetworkInfo {\n  Future<bool> get isConnected;\n}\n\nclass NetworkInfoImpl implements NetworkInfo {\n  final Connectivity connectivity;\n\n  NetworkInfoImpl\\(this.connectivity\\);\n\n  @override\n  Future<bool> get isConnected async {\n    final results = await connectivity.checkConnectivity\\(\\);\n    return results.any\\(\\(r\\) => r != ConnectivityResult.none\\);\n  }\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/skin_profile.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass SkinProfile extends Equatable {\n  final String userId;\n  final String? skinType;\n  final List<String> concerns;\n  final String? memo;\n\n  const SkinProfile\\({\n    required this.userId,\n    this.skinType,\n    this.concerns = const [],\n    this.memo,\n  }\\);\n\n  @override\n  List<Object?> get props => [userId, skinType, concerns, memo];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/notification_settings.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass NotificationSettings extends Equatable {\n  final String userId;\n  final bool pushEnabled;\n  final bool emailEnabled;\n  final bool usageReminder;\n  final String reminderTime;\n  final bool marketingEnabled;\n\n  const NotificationSettings\\({\n    required this.userId,\n    this.pushEnabled = true,\n    this.emailEnabled = true,\n    this.usageReminder = false,\n    this.reminderTime = '09:00',\n    this.marketingEnabled = false,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        userId,\n        pushEnabled,\n        emailEnabled,\n        usageReminder,\n        reminderTime,\n        marketingEnabled,\n      ];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/user_goal.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass UserGoal extends Equatable {\n  final String id;\n  final String userId;\n  final String goalType;\n  final int targetMinutes;\n  final DateTime startDate;\n  final DateTime endDate;\n  final bool isActive;\n  final DateTime createdAt;\n\n  const UserGoal\\({\n    required this.id,\n    required this.userId,\n    required this.goalType,\n    required this.targetMinutes,\n    required this.startDate,\n    required this.endDate,\n    this.isActive = true,\n    required this.createdAt,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        id,\n        userId,\n        goalType,\n        targetMinutes,\n        startDate,\n        endDate,\n        isActive,\n        createdAt,\n      ];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/server_device.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass ServerDevice extends Equatable {\n  final String id;\n  final String userId;\n  final String serialNumber;\n  final String modelName;\n  final String? firmwareVersion;\n  final String? bleMacAddress;\n  final String? nickname;\n  final bool isActive;\n  final DateTime registeredAt;\n  final int totalSessions;\n  final DateTime? lastSyncedAt;\n\n  const ServerDevice\\({\n    required this.id,\n    required this.userId,\n    required this.serialNumber,\n    this.modelName = 'DualTetraX',\n    this.firmwareVersion,\n    this.bleMacAddress,\n    this.nickname,\n    this.isActive = true,\n    required this.registeredAt,\n    this.totalSessions = 0,\n    this.lastSyncedAt,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        id,\n        userId,\n        serialNumber,\n        modelName,\n        firmwareVersion,\n        bleMacAddress,\n        nickname,\n        isActive,\n        registeredAt,\n        totalSessions,\n        lastSyncedAt,\n      ];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/server_statistics.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass ServerDailyStats extends Equatable {\n  final String date;\n  final int totalSessions;\n  final int totalDuration;\n  final int ushotSessions;\n  final int ushotDuration;\n  final int eshotSessions;\n  final int eshotDuration;\n  final int ledSessions;\n  final int ledDuration;\n  final Map<String, int> modeBreakdown;\n  final Map<String, int> levelBreakdown;\n  final int warningCount;\n\n  const ServerDailyStats\\({\n    required this.date,\n    this.totalSessions = 0,\n    this.totalDuration = 0,\n    this.ushotSessions = 0,\n    this.ushotDuration = 0,\n    this.eshotSessions = 0,\n    this.eshotDuration = 0,\n    this.ledSessions = 0,\n    this.ledDuration = 0,\n    this.modeBreakdown = const {},\n    this.levelBreakdown = const {},\n    this.warningCount = 0,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        date,\n        totalSessions,\n        totalDuration,\n        ushotSessions,\n        eshotSessions,\n        ledSessions,\n        warningCount,\n      ];\n}\n\nclass ServerRangeStats extends Equatable {\n  final String startDate;\n  final String endDate;\n  final List<ServerPeriodStats> data;\n  final int summaryTotalSessions;\n  final int summaryTotalDuration;\n  final double avgSessionsPerDay;\n\n  const ServerRangeStats\\({\n    required this.startDate,\n    required this.endDate,\n    this.data = const [],\n    this.summaryTotalSessions = 0,\n    this.summaryTotalDuration = 0,\n    this.avgSessionsPerDay = 0,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        startDate,\n        endDate,\n        data,\n        summaryTotalSessions,\n        summaryTotalDuration,\n      ];\n}\n\nclass ServerPeriodStats extends Equatable {\n  final String period;\n  final int totalSessions;\n  final int totalDuration;\n  final int ushotSessions;\n  final int eshotSessions;\n  final int ledSessions;\n\n  const ServerPeriodStats\\({\n    required this.period,\n    this.totalSessions = 0,\n    this.totalDuration = 0,\n    this.ushotSessions = 0,\n    this.eshotSessions = 0,\n    this.ledSessions = 0,\n  }\\);\n\n  @override\n  List<Object?> get props => [\n        period,\n        totalSessions,\n        totalDuration,\n        ushotSessions,\n        eshotSessions,\n        ledSessions,\n      ];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/entities/firmware_update.dart << 'DARTEOF'\nimport 'package:equatable/equatable.dart';\n\nclass FirmwareUpdate extends Equatable {\n  final bool updateAvailable;\n  final FirmwareVersion? firmware;\n\n  const FirmwareUpdate\\({\n    required this.updateAvailable,\n    this.firmware,\n  }\\);\n\n  @override\n  List<Object?> get props => [updateAvailable, firmware];\n}\n\nclass FirmwareVersion extends Equatable {\n  final String id;\n  final String version;\n  final int versionCode;\n  final String? changelog;\n  final String? binaryUrl;\n  final int? binarySize;\n  final String? binaryChecksum;\n  final int? minVersionCode;\n  final bool isActive;\n  final DateTime createdAt;\n\n  const FirmwareVersion\\({\n    required this.id,\n    required this.version,\n    required this.versionCode,\n    this.changelog,\n    this.binaryUrl,\n    this.binarySize,\n    this.binaryChecksum,\n    this.minVersionCode,\n    this.isActive = true,\n    required this.createdAt,\n  }\\);\n\n  @override\n  List<Object?> get props => [id, version, versionCode, isActive];\n}\nDARTEOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/auth_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/auth_user.dart';\n\nabstract class AuthRepository {\n  Future<Either<Failure, AuthUser>> loginWithEmail\\(String email, String password\\);\n  Future<Either<Failure, AuthUser>> signupWithEmail\\(String email, String password\\);\n  Future<Either<Failure, AuthUser>> loginWithGoogle\\(\\);\n  Future<Either<Failure, AuthUser>> loginWithApple\\(\\);\n  Future<Either<Failure, void>> logout\\(\\);\n  Future<Either<Failure, AuthUser>> autoLogin\\(\\);\n  Future<Either<Failure, AuthUser?>> getCurrentUser\\(\\);\n  Future<Either<Failure, void>> resetPassword\\(String email\\);\n  Stream<AuthUser?> get authStateChanges;\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/server_device_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/server_device.dart';\n\nabstract class ServerDeviceRepository {\n  Future<Either<Failure, List<ServerDevice>>> getDevices\\(\\);\n  Future<Either<Failure, ServerDevice>> registerDevice\\({\n    required String serialNumber,\n    String? modelName,\n    String? firmwareVersion,\n    String? bleMacAddress,\n  }\\);\n  Future<Either<Failure, ServerDevice>> getDevice\\(String id\\);\n  Future<Either<Failure, ServerDevice>> updateDevice\\(String id, {String? nickname, String? firmwareVersion}\\);\n  Future<Either<Failure, void>> deleteDevice\\(String id\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/session_sync_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/usage_session.dart';\n\nclass SessionUploadResult {\n  final int uploaded;\n  final int duplicates;\n  final int errors;\n\n  const SessionUploadResult\\({\n    this.uploaded = 0,\n    this.duplicates = 0,\n    this.errors = 0,\n  }\\);\n}\n\nabstract class SessionSyncRepository {\n  Future<Either<Failure, SessionUploadResult>> uploadSessions\\({\n    required String deviceId,\n    required List<UsageSession> sessions,\n  }\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/profile_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/user_profile.dart';\nimport '../entities/skin_profile.dart';\nimport '../entities/notification_settings.dart';\n\nabstract class ProfileRepository {\n  Future<Either<Failure, UserProfile>> getProfile\\(\\);\n  Future<Either<Failure, UserProfile>> updateProfile\\({\n    String? name,\n    String? gender,\n    String? dateOfBirth,\n    String? timezone,\n  }\\);\n  Future<Either<Failure, SkinProfile>> getSkinProfile\\(\\);\n  Future<Either<Failure, SkinProfile>> updateSkinProfile\\({\n    String? skinType,\n    List<String>? concerns,\n    String? memo,\n  }\\);\n  Future<Either<Failure, NotificationSettings>> getNotificationSettings\\(\\);\n  Future<Either<Failure, NotificationSettings>> updateNotificationSettings\\({\n    bool? pushEnabled,\n    bool? emailEnabled,\n    bool? usageReminder,\n    String? reminderTime,\n    bool? marketingEnabled,\n  }\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/goal_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/user_goal.dart';\n\nabstract class GoalRepository {\n  Future<Either<Failure, List<UserGoal>>> getGoals\\(\\);\n  Future<Either<Failure, UserGoal>> createGoal\\({\n    required String goalType,\n    required int targetMinutes,\n    required String startDate,\n    required String endDate,\n  }\\);\n  Future<Either<Failure, UserGoal>> updateGoal\\(String id, {int? targetMinutes, bool? isActive}\\);\n  Future<Either<Failure, void>> deleteGoal\\(String id\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/repositories/server_firmware_repository.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../core/errors/failures.dart';\nimport '../entities/firmware_update.dart';\n\nabstract class ServerFirmwareRepository {\n  Future<Either<Failure, FirmwareUpdate>> checkForUpdate\\({int currentVersionCode = 0}\\);\n  Future<Either<Failure, FirmwareVersion>> getLatestFirmware\\(\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/login_with_email.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/auth_user.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass LoginWithEmail extends UseCase<AuthUser, LoginParams> {\n  final AuthRepository repository;\n  LoginWithEmail\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, AuthUser>> call\\(LoginParams params\\) {\n    return repository.loginWithEmail\\(params.email, params.password\\);\n  }\n}\n\nclass LoginParams {\n  final String email;\n  final String password;\n  const LoginParams\\({required this.email, required this.password}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/signup_with_email.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/auth_user.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass SignupWithEmail extends UseCase<AuthUser, SignupParams> {\n  final AuthRepository repository;\n  SignupWithEmail\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, AuthUser>> call\\(SignupParams params\\) {\n    return repository.signupWithEmail\\(params.email, params.password\\);\n  }\n}\n\nclass SignupParams {\n  final String email;\n  final String password;\n  const SignupParams\\({required this.email, required this.password}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/logout.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass Logout extends UseCase<void, NoParams> {\n  final AuthRepository repository;\n  Logout\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, void>> call\\(NoParams params\\) {\n    return repository.logout\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/auto_login.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/auth_user.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass AutoLogin extends UseCase<AuthUser, NoParams> {\n  final AuthRepository repository;\n  AutoLogin\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, AuthUser>> call\\(NoParams params\\) {\n    return repository.autoLogin\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/login_with_google.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/auth_user.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass LoginWithGoogle extends UseCase<AuthUser, NoParams> {\n  final AuthRepository repository;\n  LoginWithGoogle\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, AuthUser>> call\\(NoParams params\\) {\n    return repository.loginWithGoogle\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/auth/login_with_apple.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/auth_user.dart';\nimport '../../repositories/auth_repository.dart';\n\nclass LoginWithApple extends UseCase<AuthUser, NoParams> {\n  final AuthRepository repository;\n  LoginWithApple\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, AuthUser>> call\\(NoParams params\\) {\n    return repository.loginWithApple\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/devices/register_server_device.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/server_device.dart';\nimport '../../repositories/server_device_repository.dart';\n\nclass RegisterServerDevice extends UseCase<ServerDevice, RegisterDeviceParams> {\n  final ServerDeviceRepository repository;\n  RegisterServerDevice\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, ServerDevice>> call\\(RegisterDeviceParams params\\) {\n    return repository.registerDevice\\(\n      serialNumber: params.serialNumber,\n      modelName: params.modelName,\n      firmwareVersion: params.firmwareVersion,\n      bleMacAddress: params.bleMacAddress,\n    \\);\n  }\n}\n\nclass RegisterDeviceParams {\n  final String serialNumber;\n  final String? modelName;\n  final String? firmwareVersion;\n  final String? bleMacAddress;\n\n  const RegisterDeviceParams\\({\n    required this.serialNumber,\n    this.modelName,\n    this.firmwareVersion,\n    this.bleMacAddress,\n  }\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/devices/get_server_devices.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/server_device.dart';\nimport '../../repositories/server_device_repository.dart';\n\nclass GetServerDevices extends UseCase<List<ServerDevice>, NoParams> {\n  final ServerDeviceRepository repository;\n  GetServerDevices\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, List<ServerDevice>>> call\\(NoParams params\\) {\n    return repository.getDevices\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/sync/upload_sessions_to_server.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/sync_status.dart';\nimport '../../repositories/session_sync_repository.dart';\nimport '../../repositories/usage_repository.dart';\nimport '../../../data/datasources/usage_local_data_source.dart';\n\nclass UploadSessionsToServer extends UseCase<SessionUploadResult, UploadSessionsParams> {\n  final SessionSyncRepository sessionSyncRepository;\n  final UsageRepository usageRepository;\n  final UsageLocalDataSource usageLocalDataSource;\n\n  UploadSessionsToServer\\({\n    required this.sessionSyncRepository,\n    required this.usageRepository,\n    required this.usageLocalDataSource,\n  }\\);\n\n  @override\n  Future<Either<Failure, SessionUploadResult>> call\\(UploadSessionsParams params\\) async {\n    try {\n      final sessions = await usageLocalDataSource.getSessionsBySyncStatus\\(\n        SyncStatus.syncedToApp,\n      \\);\n\n      if \\(sessions.isEmpty\\) {\n        return const Right\\(SessionUploadResult\\(\\)\\);\n      }\n\n      int totalUploaded = 0;\n      int totalDuplicates = 0;\n      int totalErrors = 0;\n\n      // Batch upload in groups of 100\n      for \\(var i = 0; i < sessions.length; i += 100\\) {\n        final batch = sessions.sublist\\(\n          i,\n          i + 100 > sessions.length ? sessions.length : i + 100,\n        \\);\n\n        final result = await sessionSyncRepository.uploadSessions\\(\n          deviceId: params.serverDeviceId,\n          sessions: batch,\n        \\);\n\n        result.fold\\(\n          \\(failure\\) {\n            totalErrors += batch.length;\n          },\n          \\(uploadResult\\) {\n            totalUploaded += uploadResult.uploaded;\n            totalDuplicates += uploadResult.duplicates;\n            totalErrors += uploadResult.errors;\n\n            // Update sync status for successfully uploaded sessions\n            for \\(final session in batch\\) {\n              usageRepository.updateSyncStatus\\(\n                session.uuid,\n                SyncStatus.syncedToServer,\n              \\);\n            }\n          },\n        \\);\n      }\n\n      return Right\\(SessionUploadResult\\(\n        uploaded: totalUploaded,\n        duplicates: totalDuplicates,\n        errors: totalErrors,\n      \\)\\);\n    } catch \\(e\\) {\n      return Left\\(ServerFailure\\(e.toString\\(\\)\\)\\);\n    }\n  }\n}\n\nclass UploadSessionsParams {\n  final String serverDeviceId;\n  const UploadSessionsParams\\({required this.serverDeviceId}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/profile/get_profile.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/user_profile.dart';\nimport '../../repositories/profile_repository.dart';\n\nclass GetProfile extends UseCase<UserProfile, NoParams> {\n  final ProfileRepository repository;\n  GetProfile\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, UserProfile>> call\\(NoParams params\\) {\n    return repository.getProfile\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/profile/update_profile.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/user_profile.dart';\nimport '../../repositories/profile_repository.dart';\n\nclass UpdateProfile extends UseCase<UserProfile, UpdateProfileParams> {\n  final ProfileRepository repository;\n  UpdateProfile\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, UserProfile>> call\\(UpdateProfileParams params\\) {\n    return repository.updateProfile\\(\n      name: params.name,\n      gender: params.gender,\n      dateOfBirth: params.dateOfBirth,\n      timezone: params.timezone,\n    \\);\n  }\n}\n\nclass UpdateProfileParams {\n  final String? name;\n  final String? gender;\n  final String? dateOfBirth;\n  final String? timezone;\n\n  const UpdateProfileParams\\({this.name, this.gender, this.dateOfBirth, this.timezone}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/goals/get_goals.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/user_goal.dart';\nimport '../../repositories/goal_repository.dart';\n\nclass GetGoals extends UseCase<List<UserGoal>, NoParams> {\n  final GoalRepository repository;\n  GetGoals\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, List<UserGoal>>> call\\(NoParams params\\) {\n    return repository.getGoals\\(\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/goals/create_goal.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/user_goal.dart';\nimport '../../repositories/goal_repository.dart';\n\nclass CreateGoal extends UseCase<UserGoal, CreateGoalParams> {\n  final GoalRepository repository;\n  CreateGoal\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, UserGoal>> call\\(CreateGoalParams params\\) {\n    return repository.createGoal\\(\n      goalType: params.goalType,\n      targetMinutes: params.targetMinutes,\n      startDate: params.startDate,\n      endDate: params.endDate,\n    \\);\n  }\n}\n\nclass CreateGoalParams {\n  final String goalType;\n  final int targetMinutes;\n  final String startDate;\n  final String endDate;\n\n  const CreateGoalParams\\({\n    required this.goalType,\n    required this.targetMinutes,\n    required this.startDate,\n    required this.endDate,\n  }\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/goals/update_goal.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/user_goal.dart';\nimport '../../repositories/goal_repository.dart';\n\nclass UpdateGoal extends UseCase<UserGoal, UpdateGoalParams> {\n  final GoalRepository repository;\n  UpdateGoal\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, UserGoal>> call\\(UpdateGoalParams params\\) {\n    return repository.updateGoal\\(\n      params.id,\n      targetMinutes: params.targetMinutes,\n      isActive: params.isActive,\n    \\);\n  }\n}\n\nclass UpdateGoalParams {\n  final String id;\n  final int? targetMinutes;\n  final bool? isActive;\n\n  const UpdateGoalParams\\({required this.id, this.targetMinutes, this.isActive}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/goals/delete_goal.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../repositories/goal_repository.dart';\n\nclass DeleteGoal extends UseCase<void, String> {\n  final GoalRepository repository;\n  DeleteGoal\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, void>> call\\(String params\\) {\n    return repository.deleteGoal\\(params\\);\n  }\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/stats/get_server_daily_stats.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/server_statistics.dart';\nimport '../../repositories/server_stats_repository.dart';\n\nclass GetServerDailyStats extends UseCase<ServerDailyStats, DailyStatsParams> {\n  final ServerStatsRepository repository;\n  GetServerDailyStats\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, ServerDailyStats>> call\\(DailyStatsParams params\\) {\n    return repository.getDailyStats\\(date: params.date, deviceId: params.deviceId\\);\n  }\n}\n\nclass DailyStatsParams {\n  final String? date;\n  final String? deviceId;\n  const DailyStatsParams\\({this.date, this.deviceId}\\);\n}\nDART_EOF)",
      "Bash(/Users/oz/motionx/qp_prjs/DualTetraX/services/mobile_app/lib/domain/usecases/firmware/check_firmware_update.dart << 'DART_EOF'\nimport 'package:dartz/dartz.dart';\nimport '../../../core/errors/failures.dart';\nimport '../../../core/usecases/usecase.dart';\nimport '../../entities/firmware_update.dart';\nimport '../../repositories/server_firmware_repository.dart';\n\nclass CheckFirmwareUpdate extends UseCase<FirmwareUpdate, int> {\n  final ServerFirmwareRepository repository;\n  CheckFirmwareUpdate\\(this.repository\\);\n\n  @override\n  Future<Either<Failure, FirmwareUpdate>> call\\(int currentVersionCode\\) {\n    return repository.checkForUpdate\\(currentVersionCode: currentVersionCode\\);\n  }\n}\nDART_EOF)",
      "Bash(flutter analyze:*)"
    ]
  }
}
